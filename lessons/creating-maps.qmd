---
title: "Creating maps"
format: html
include-in-header: "components/add-answer-button.html"
---

::: summary
## Questions

-   How do we create maps using R?

## Objectives

-   Learn how to plot iNaturalist observations on a map.
-   Learn how to create static maps with ggplot2.
-   Learn how to create interactive maps with mapview.
:::

## Mapping iNaturalist data

iNaturalist data includes latitude and longitude information, which means we can put the observations on a map.

Main steps:

1.  Load iNaturalist data
2.  Add geometry column to iNaturalist data
3.  Use `filter()`, `select(),` `mutate()`, and `count()` to get the rows and columns we want
4.  Create map

Loading R packages. We will use **ggplot, sf** and **mapview** packages to create maps.

```{r, load_packages}
#| error: false
#| warning: false
#| message: false

library(readr) # read and write tabular data
library(dplyr) # manipulate data

library(ggplot2) # create data visualizations
library(sf) # handle geospatial data
library(mapview) # create interactive maps
```

First, we need to read data from the CNC iNaturalist observation file.

```{r, read_data_from_csv}
#| warning: false
#| message: false
inat_data <- read_csv('data/cleaned/cnc-los-angeles-observations.csv')

```

We can use `names()` to see all the column names. "latitude" and "longitude" are the column names we need.

```{r, get_column_names}
names(inat_data)
```

`st_as_sf()` function from **sf** package will take the longitude and latitude values and add a `geometry` column that we can use for mapping.

-   We pass in longitude and latitude columns as a vector to `coords` argument. We must wrap longitude and latitude in quotes.
-   `crs` argument sets the [coordinate reference system](intro-science-coding.qmd#coordinate-reference-systems) (CRS). 4326 is the code for the EPSG:4326, a commonly used CRS.
-   `st_as_sf()` removes the `longitude` and `latitude` columns and adds a `geometry` column.

```{r, select_columns}
inat_map_base <- inat_data %>% 
  st_as_sf(coords = c("longitude", "latitude"),   crs = 4326)
```

`st_crs()` from **sf** returns the CRS for a data frame. Let's use `st_crs()` to look at the CRS.

```{r examine_inat_map_crs}
st_crs(inat_map_base)
```

Let's look at the `geometry` value for the first observation. `inat_map$geometry` returns all the values in `geometry` column as a vector. `[1]` returns the the geometry value in the first observation.

```{r examine_inat_map_geometry}
inat_map_base$geometry[1]
```

For this workshop, we won't go into details about what all this information means. Just be aware that **sf** package needs certain information to process geospatial data.

We use `select()` to pick which columns we want for the map.

```{r select_inat_map columns}
 inat_map <- inat_map_base %>% 
  select(user_login, common_name, scientific_name, observed_on,  url, geometry, quality_grade) 
```

Use `dim()` to show the number of rows and columns. There are over 191K rows.

```{r, size_of_dataframe}
dim(inat_map)
```

Let's get the observations for 'Quercus agrifolia' aka Coast Live Oak.

```{r, get_oak_data}
inat_oak_map <- inat_map %>% 
  filter(scientific_name == 'Quercus agrifolia')
```

Use `dim()` to get number of observations. There is 711 rows.

```{r, get_size_of_oak_dataframe}
dim(inat_oak_map)
```

## static map

**ggplot2** is a powerful package that allows you to create complex plots from tabular data (data in a table format with rows and columns). The **gg** in **ggplot2** stands for “grammar of graphics”, and the package uses consistent vocabulary to create plots step by step by adding new layers, which allows for extensive flexibility and customization of plots. **ggplot2** is most commonly used for charts, but it can also be used to create static maps.

Let's create a map for Coast Live Oak observations.

Call `ggplot()` to start a map. Then we use `+` to add a new layer to the map. We pass the iNaturalist data to `geom_sf()` using the `data` argument. `geom_sf()` uses the information in the `geometry` column to plot each row.

```{r, create_static_map_for_oak}
ggplot() +
  geom_sf(data = inat_oak_map)   
```

## interactive map

We can use **mapview** package to create interactive maps where you can zoom in and out.

Let's create interactive map for 'Coast Live Oak'.

```{r, create_interactive_map}
#| eval: false
mapview(inat_oak_map)
```

![](images/mapview/creating_maps/create_interactive_map.png){fig-alt="create interactive map"}

You can zoom in and out. When you click on layer button on the left, you can change base map and turn on/off layers. When you click on a map marker, all the fields that were passed into `select()` will be displayed in a popup. Clicking on the layer names in the lower right will zoom the map to show all objects in the layer.

## Using other geospatial files

Let's add the boundaries for LA County to the map.

There are various places where you can download geospatial files for free. We downloaded the LA County boundaries from [LA City Geohub](https://geohub.lacity.org/datasets/lacounty::la-county-boundary-7/about). Geohub offers files in various formats including CSV, Shapefile, GeoJSON, and KML. We are using a Shapefile.

`read_sf()` function from **sf** package can read files and databases in various formats. We will use `read_sf()` to read the LA County boundary file.

```{r, get_LA_County_boundaries}
la_county_boundary <- read_sf('data/raw/LA_County_Boundary/LA_County_Boundary.shp')
```

We can use `glimpse()` to examine the LA County boundary file.

```{r glimspe_la_county_boundary}
glimpse(la_county_boundary)
```

Shapefiles includes a `geometry` column.

When working with multiple geospatial files, it's important that all the data uses the same [coordinate reference system (CRS)](intro-science-coding.qmd#coordinate-reference-systems). Let’s use `st_crs()` to check if the CRS for the iNaturalist data and the LA County boundary are the same. `==` checks if two things are equal.

```{r check_la_county_and_inat_crs}
st_crs(la_county_boundary) == st_crs(inat_oak_map)
```

Since the CRS are different, we need to use `st_transform()` to change the CRS of the LA County boundary. First argument is the data frame. `crs` is the new CRS value.

```{r update_la_county_crs}
la_county_boundary <- st_transform(la_county_boundary,  crs = st_crs(inat_oak_map))

st_crs(la_county_boundary) == st_crs(inat_oak_map)
```

### Static maps

Let's create a static map with LA County and oak observations. Create a new layer for each data set using two `geom_sf()` and `+`.

```{r, add_LA_County_to_static_map}
ggplot() +
  geom_sf(data = la_county_boundary)  +
  geom_sf(data = inat_oak_map) 
```

When **ggplot2** draws the iNaturalist observations, it draws a round circle. When it draws the LA County boundary, it draws a polygon (closed shape with many sides). The data in the `geometry` column determines how **ggplot2** draws things.

```{r check_la_county_geometry}
la_county_boundary$geometry[1]
```

```{r check_inat_geometry}
inat_oak_map$geometry[1]
```

The Geometry type for the LA County boundary is a MULTIPOLYGON, and for iNaturalist is a POINT.

For points, use the `color` argument to set the color. For polygons, use `color` to set the border color and `fill` to set the fill color.

```{r, create_static_map_for_oak_use_color}
ggplot() +
  geom_sf(data = la_county_boundary, color="black", fill='beige')  +
  geom_sf(data = inat_oak_map, color='green')  
```

We can also use `alpha()` to set the opacity. 0 is transparent, 1 is solid.

```{r, create_static_map_for_oak_use_alpha}
ggplot() +
  geom_sf(data = la_county_boundary, color="black", fill=alpha('beige', .5))  +
  geom_sf(data = inat_oak_map, color=alpha('green', .3))  
```

Instead of using one color for all the observations, we can also set the color to represent values in a particular column using `geom_sf(mapping=aes(color=<column_name>))`. `mapping` argument tells **ggplot2** how relate data values to elements in the plot. `aes()` function is short for aesthetic mappings, and it describes how data are mapped to visual properties. We set the `color` argument to the name of a column.

Let's use `quality_grade` to set the color of the map markers.

```{r, create_static_map_for_oak_use_quality_grade}

ggplot() +
  geom_sf(data = la_county_boundary, color="black", fill='beige')  +
  geom_sf(data = inat_oak_map, mapping=aes(color=quality_grade))  

```

**ggplot2** will assign a different color to each value, and add a legend.

We can set the map title and legend title using `labs(title='', subtitle='', color='')`. We can add `theme_void()` to get rid of the grey background and axis labels.

```{r add_title_to_static_map}
ggplot() +
  geom_sf(data = la_county_boundary, color="black", fill='beige')  +
  geom_sf(data = inat_oak_map, mapping=aes(color=quality_grade)) +
  labs(title = 'CNC observations for Live Coast Oaks in LA County',
       subtitle='2016-2024',
       color='Quality Grade') +
  theme_void()

```

### Interactive maps

Let's create an interactive map with LA County and oak observations. Create a new layer for each data set using `+`.

```{r, add_LA_County_to_interactive_map}
#| eval: false
mapview(la_county_boundary) +
  mapview(inat_oak_map) 
```

![](images/mapview/creating_maps/add_LA_County_to_interactive_map.png){fig-alt="add LA County boundaries to interactive map"}

mapview will add a legend for each layer. We can hide the legend with `legend=FALSE`.

```{r, add_LA_County_to_interactive_map_remove_legend}
#| eval: false
mapview(la_county_boundary, legend=FALSE) +
  mapview(inat_oak_map, legend=FALSE) 
```

![](images/mapview/creating_maps/add_LA_County_to_interactive_map_remove_legend.png){fig-alt="add LA County to interactive map and remove legend"}

When you hover over an item on the map, a small popup will be shown. When you click on an item, a popup with the fields from the `select()` will be shown.

We can turn off the small popup with `label=FALSE`, and turn off the large popup with `popup=FALSE`

```{r add_LA_County_to_interactive_map_remove_popup}
#| eval: false
mapview(la_county_boundary, legend=FALSE, popup=FALSE, label=FALSE) +
  mapview(inat_oak_map, legend=FALSE) 
```

Use `color` to set the border color, and `col.regions` to set the color of the fill.

```{r, create_interactive_map_use_color}
#| eval: false
mapview(la_county_boundary, legend=FALSE,
        popup=FALSE, label=FALSE,
        color='black', col.regions='beige') +
  mapview(inat_oak_map, legend=FALSE,
          color='black', col.regions='green') 
```

![](images/mapview/creating_maps/create_interactive_map_use_color.png){fig-alt="create interactive map and set colors"}

::: callout-note
By default, mapview will draw purple layers and use CartoDB Positron base map.

If we use custom colors, mapview will pick a base map based on the custom colors. If we want mapview to always use CartoDB Positron base map, we need to turn off color shuffle.

```         
mapviewOptions(basemaps.color.shuffle = FALSE)
```
:::

```{r}
mapviewOptions(basemaps.color.shuffle = FALSE)
```

We can also use `alpha.region` to set the opacity. 0 is transparent, 1 is solid.

```{r, create_interactive_map_set_opacity}
#| eval: false
mapview(la_county_boundary, legend=FALSE,
        popup=FALSE, label=FALSE,
        color='black', col.regions='beige',
         alpha.region=1) +
  mapview(inat_oak_map, legend=FALSE,
          color='black', col.regions='green',
          alpha.region=1) 
```

![](images/mapview/creating_maps/create_interactive_map_set_opacity){fig-alt="create interactive map and set opacity"}

We can also set the color of the observation to represent values in a particular column using `zcol=<column_name>`.

Let's use `quality_grade` to set the color of the map markers.

```{r, create_interactive_map_and_show_quality_grade}
#| eval: false

mapview(la_county_boundary, legend=FALSE,
        popup=FALSE, label=FALSE,
        color='black', col.regions='beige') +
  mapview(inat_oak_map, zcol='quality_grade')
```

![](images/mapview/creating_maps/create_interactive_map_for_oak_use_quality_grade.png){fig-alt="create interactive map and add quality grade"}

We can set the legend title using `layer.name`. mapview does not have the ability to add a title.

```{r create_interactive_map_and_rename_legend_title}
#| eval: false
mapview(la_county_boundary, legend=FALSE,
        popup=FALSE, label=FALSE,
        color='black', col.regions='beige') +
  mapview(inat_oak_map, zcol='quality_grade',
          layer.name='Quality Grade')

```

![](images/mapview/creating_maps/create_interactive_map_and_rename_legend_title.png){fig-alt="create interactive map and rename legend title"}

:::: exercise
## Exercise 1

Create a map for one species. Include the boundaries for LA County.

-   use `filter()` to select observations for one species
-   create either a static or interactive map.

::: answer
```{r, exercise_create_map_one_species}
#| eval: false
inat_finch <- inat_map %>% 
  filter(common_name == 'House Finch')

mapview(la_county_boundary) + 
  mapview(inat_finch)
```
:::
::::

## Observations in a specific area

Let's look for all iNaturalist observations made in Exposition Park.

Sometimes we won't be able to find a pre-existing file that has boundaries for an area that we want to analyze. In these cases, we need to create our own boundaries. I used this [Draw map boundaries](https://wykhuh.github.io/draw-map-boundaries/) webpage to draw and download the boundaries of Exposition Park. The file is in GeoJSON format.

Let's use `read_sf()` to read a GeoJSON file.

```{r, get_Expo_park_boundaries}
expo_park_boundary <- read_sf('data/raw/boundaries_expo_park_area.geojson')  
```

We can use `glimpse()` to examine the file.

```{r}
glimpse(expo_park_boundary)
```

The GeoJSON file has a `geometry` column.

Let's use `st_crs()` to check if the CRS for the iNaturalist data and Expo Park are the same.

```{r, check_crs}
st_crs(expo_park_boundary) == st_crs(inat_map)
```

Let's create static and interactive maps of Expo Park.

```{r, create_static_map_expo_park}
ggplot() +
  geom_sf(data = expo_park_boundary) 
```

```{r,create_interactive_map_expo_park}
#| eval: false
mapview(expo_park_boundary) 
```

![](images/mapview/creating_maps/create_interactive_map_expo_park.png){fig-alt="create interactive map for exposition park"}

The following code will get the observations that are inside Exposition Park. We will save the observations to `inat_expo`.

```{r, get_all_observations_within_expo_park}
inat_expo <- inat_map[lengths(st_intersects(inat_map, expo_park_boundary)) > 0, ]

inat_expo
```

::: callout-note
For those who want to understand that chunk of code, here's a explanation.

`st_intersects()` from **sf** tells us the number of items in one spatial object touch, cross, or is within items in a second spatial object.

The following code returns the number of items in each row of `inat_map` that is within `expo_park_boundary`. Since each row only contains one location, we will either get 1 or empty.

```{r, st_intersects}
st_intersects(inat_map, expo_park_boundary)
```

We use `lengths(st_intersects(inat_map, expo_park_boundary)) > 0` to check it the row has items within Exposition Park. If a row has 1 item inside `expo_park_boundary`, return TRUE. Otherwise return FALSE. This will create a vector of with TRUE and FALSE values, also known as logical vector.

```{r, get_true_false}
# we are limited the output to the first 50 rows for this explation
(lengths(st_intersects(inat_map, expo_park_boundary)) > 0)[1:50]
```

We can use a logical vectors to filter rows in data frame by using `dataframe[logical_vector, ]`. If the logical vector is TRUE, return the row. Otherwise ignore the row.

This code selects all rows in `inat_map` where there is one or more items in the row that are inside `expo_park_boundary`

```{r, all_observations_within_expo_park}
inat_expo_2 <- inat_map[lengths(st_intersects(inat_map, expo_park_boundary)) > 0, ]
```
:::

Use `dim()` to get row and column count. 191K observations in LA county, 2964 observation in Expo Park.

```{r, compare_size_of_dataframes}
dim(inat_map)

dim(inat_expo)
```

Let's create map of all observations in Expo Park.

```{r, create_static_map_of_observations_in_expo_park}
ggplot() +
  geom_sf(data = expo_park_boundary)  +
  geom_sf(data = inat_expo) 
```

```{r,create_interactive_map_of_observations_in_expo_park}
#| eval: false
mapview(expo_park_boundary) +
  mapview(inat_expo) 

```

![](images/mapview/creating_maps/create_interactive_map_of_observations_in_expo_park.png){fig-alt="create interactive map of observations in exposition park"}

:::: exercise
## Exercise 2

Create a map for all CNC observations that are inside of a specific area

-   Used [Draw map boundaries](https://wykhuh.github.io/draw-map-boundaries/) to draw and download an area that you are interested in.
-   Save the file to the `data/raw` directory.
-   use `read_sf` to read your boundary data.
-   use `inat_map[lengths(st_intersects(inat_map, your_boundary)) > 0, ]` to get observations inside a boundary

::: answer
```{r,exercise_create_map_of_observations_inside_boundary}
#| eval: false

usc_boundary <- read_sf('data/raw/boundaries_usc.geojson')  %>% 
  st_transform(st_crs(inat_usc))

inat_usc <- inat_map[st_intersects(inat_map, usc_boundary) %>% lengths > 0, ]

mapview(usc_boundary) + 
  mapview(inat_usc)
```
:::
::::

## Observations near a specific region

In geospatial analysis, buffer refers to the area within a certain distance of a specified feature. In the example below, the blue line is the specified feature, and the pinkish area is the buffer.

![Bplewe, CC BY-SA 4.0 \<https://creativecommons.org/licenses/by-sa/4.0\>, via Wikimedia Commons](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/GIS_Buffer.png/288px-GIS_Buffer.png)

Let's find observations within 1/2 mile of the Los Angeles River. In other words, we want to create a 1/2 mile buffer around the LA River, and find the iNaturalist observations inside the buffer.

Load the LA River boundary.

```{r}
la_river <- read_sf('data/cleaned/los_angeles_river.geojson')
```

Check CRS for LA River and iNaturalist are the same.

```{r}
st_crs(la_river) == st_crs(inat_map)
```

Change LA River CRS.

```{r}
la_river <- st_transform(la_river, crs = st_crs(inat_map))

st_crs(la_river) == st_crs(inat_map)
```

`st_buffer()` function from **sf** computes a buffer around a feature. The first argument is a **sf** object. The second argument `dist` is the distance around the given object. The units for `dist` depend on the CRS.

Some CRS use angle degrees for the units. EPSG:4326 is an example. Some CRS use meters for the units. EPSG:5070 is an example.

The LA River uses EPSG:4326. We need to change the CRS to EPSG:5070, add a buffer of 805 meters (1/2 mile), and then covert the buffer back to EPSG:4326

```{r}
# change CRS to 5070
river_5070 <- st_transform(la_river, crs=5070)

# create 805 meter (1/2 mile) buffer
buffer_river_5070 <- st_buffer(river_5070, 805)

# change CRS to 4326
buffer_river <- st_transform(buffer_river_5070, crs=st_crs(inat_map))
```

Add river and buffer to a map.

```{r create_map_with_la_river_and_buffer}
#| eval: false

mapview(buffer_river) +
  mapview(la_river)
```

![](images/mapview/creating_maps/create_map_with_la_river_and_buffer.png){fig-alt="create interactive map of LA River and buffer"}

```{r, get_all_observations_near_la_river}

inat_river <- inat_map_base %>% 
  select(user_login, common_name, scientific_name, taxon_kingdom_name)
  
inat_river <- inat_river[lengths(st_intersects(inat_river, buffer_river)) > 0, ]

```

```{r}
inat_river
```

We can add the iNaturalist observations to the map.

```{r create_map_with_la_river_nearby_observations}
#| eval: false

mapview(buffer_river, legend=FALSE, col.region='white', 
        popup=FALSE, label=FALSE) +
  mapview(la_river, legend = FALSE) + 
  mapview(inat_river, zcol='taxon_kingdom_name')
```

![](images/mapview/creating_maps/create_map_with_la_river_nearby_observations.png){fig-alt="create interactive map of LA River and nearby observations"}

We can also save the `inat_river` as a CSV and do further analysis such as getting taxa counts and creating charts.

## Exporting maps

We can export the maps created with **ggplot** and **mapview** as image files.

### static maps

Assign the map created by ggplot to an object. Then run \`ggsave() to save our map. The first argument is the path to the file we want to save, including the correct file extension. You can save as jpg, pdf, tiff, png. Next, we tell it the name of the plot object we want to save. We can also specify things like the width and height of the plot in inches.

```{r, save_static_map}
#| eval: false

# create map
my_map <- ggplot() +
  geom_sf(data = expo_park_boundary)  +
  geom_sf(data = inat_expo) 

# save map
ggsave(filename = 'results/expo_park_observations.jpg', plot = my_map,  height = 6, width = 8)
```

### interactive map

Assign the map created by mapview to an object. Then run `mapshot()` to save our map. The first argument is map you want to to save. The second argument `file` is the path to the file we want to save, including the correct file extension. You can save as jpg, pdf, or png.

```{r, save_interactive_map}
#| eval: false

# create map
my_map_2 <- mapview(expo_park_boundary) + 
  mapview(inat_expo)

# save map
mapshot(my_map_2, file = 'results/expo_park_observations_2.jpg')
```

You can also save the map as an interactive webpage. The second argument `url` is the path to the file we want to save. Save the file as html.

```{r, save_interactive_map_html}
#| eval: false

# save map
mapshot(my_map_2, url = 'results/expo_park_observations_2.html')
```
