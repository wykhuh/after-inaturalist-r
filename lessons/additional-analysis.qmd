---
title: "Additional Analysis"
format: html
---

In this section, we will show a few more examples of maps and charts.

For more examples of charts and graphs visit [R Graph Gallery](https://r-graph-gallery.com).

```{r, load_packages}
#| error: false
#| warning: false
#| message: false

library(readr) # read and write tabular data
library(dplyr) # manipulate data
library(lubridate) # manipulate dates
library(ggplot2) # create data visualizations
library(sf) # handle geospatial data
library(mapview) # create interactive maps
```

First, we need to read data from the CNC iNaturalist observation file.

```{r, read_data_from_csv}
#| warning: false
#| message: false
inat_data <- read_csv('data/cleaned/cnc-los-angeles-observations.csv')

```

Let's add a `geometry` column

```{r, select_columns}
inat_map <- inat_data %>% 
  st_as_sf(coords = c("longitude", "latitude"),   crs = 4326) %>% 
  select(user_login, common_name, scientific_name, observed_on,  url, geometry, quality_grade)
```

Let's get the observations for 'Quercus agrifolia' aka Coast Live Oak.

```{r, get_oak_data}
inat_oak_map <- inat_map %>% 
  filter(scientific_name == 'Quercus agrifolia')
```

Let's add a year column to iNaturalist data.

```{r, add_year_column}
inat_year <- inat_data %>% 
  mutate(year = year(observed_on)) 
```

## Stacked bar charts

We can create stacked bar charts by adding a column from the data frame to `aes()` function `fill` argument. Let's create a stacked bar chart using `quality_grade`.

```{r, create_stacked_bar_chart}
ggplot(data = inat_year, 
       mapping = aes(x = year, fill = quality_grade)) +
  geom_bar()   
```

The height of each bar represents the number of observations per year. The height of the 3 rectangles in each bar represents the number of observations that are labeled casual, needs_id, and research.

**ggplot2** assigns each quality grade a different color, and creates a legend that tells you which values goes with which color.

## Dodged bar charts

To create side-by-side dodged bar charts, use `position=position_dodge()`

```{r create_dodged_bar_chart}
ggplot(data = inat_year , 
       mapping = aes(x = year, fill = quality_grade))  +
  geom_bar(position = position_dodge(preserve = 'single'))  
```

## Multiple line charts

If we want a chart with multiple lines, we need to create a data frame with three columns: one column x axis, one column for y axis, and one column for color.

```{r create_dataframe_for_multi_line_chart}
year_quality_count <- inat_data %>% 
  mutate(year = year(observed_on))  %>%
  count(year, quality_grade,  name='count') 

year_quality_count
```

```{r create_multi_line_chart}
ggplot(data = year_quality_count, 
       mapping = aes(x = year, y = count, color = quality_grade)) +
  geom_line()
```

## Multiple charts

Each `geom_` adds a layer to the chart. We can have multiple chart layers in one chart by having multiple `geom_`.

Let's create a bar and line chart that uses the same data and mapping.

```{r, create_dataframe_with_year_count}
inat_year_count <- inat_data %>% 
  mutate(year = year(observed_on)) %>%
  count(year, name='count')  

inat_year_count
```

```{r}
ggplot(data = inat_year_count,
       mapping = aes(x = year, y = count)) +
  geom_col() +
  geom_line()
 
```

Let's create a dodged bar and line chart that uses the different data and different mapping. Instead of putting the information inside `ggplot()`, we put information in each `geom_`.

```{r, bar_and_line_chart}
ggplot() +
  geom_bar(data = inat_year , 
       mapping = aes(x = year, fill = quality_grade),
       position = position_dodge(preserve = 'single')) +
  geom_line(data = inat_year_count, 
       mapping = aes(x = year, y = count))
 
```

## Choropleth maps

Choropleth maps use colors or shades to show how data changes from place to place.

Let's create a choropleth map to show the number of CNC observations in L.A. County neighborhoods.

Los Angeles Times Data Desk developed a map that broke down L.A. County in 272 neighborhoods. <https://maps.latimes.com/about/index.html> We'll use the L.A. Times neighborhood boundaries for our map.

```{r read_neighborhood_file}
la_neighborhoods <- read_sf('data/raw/la_times_la_county_neighborhoods.json')
```

Use `glimpse()` to examine the file data.

```{r glimpse_neighborhood}
glimpse(la_neighborhoods)
```

The file has a `geometry` column.

Use `select()` to pick the `name` and `geometry` columns.

```{r select_columns_in_neighborhood}
la_neighborhoods_edit <- la_neighborhoods %>%
  select(name, geometry)

```

Check if the neighborhood maps have the same CRS as the iNaturalist data.

```{r check_neighborhood_inat_crs}
st_crs(la_neighborhoods_edit) == st_crs(inat_map)
```

Ther is a bug with **sf** <https://github.com/r-spatial/sf/issues/1762>. This bit of code is fix for the bug.

```{r fix_sf_bug}
sf_use_s2(FALSE)
```

We want to figure out how many observations are in each neighborhood. `st_join()` from **sf** figures out if items in one spatial object touch, cross, or is within items in a second spatial object. If an item intersects the second item, then the columns from the second item are added to the first item.

The following code will figure out if an observation in `inat_map` intersects the boundaries of `la_neighborhoods_edit`. If the observation intersects a neighborhood, the neighborhood `name` is added the observation. If the observation is not inside a neighborhood, `name` is set to `NA`. `NA` is a special value in R that means not applicable. `filter(!is.na(name))` selects observations where `name` is not `NA`.

```{r get_observations_within_neighborhoods}
inat_neigborhoods <- st_join(inat_map, la_neighborhoods_edit) %>%
  filter(!is.na(name)) 

glimpse(inat_neigborhoods)
```

181K out of the 191K CNC observations intersect one of the neigborhood boundaries.

Next we use `count()` to get the number of observations per neighborhood. We also use `st_drop_geometry()` from **sf** to remove the `geometry` column. We want to remove the `geometry` column because we don't need the location of each observation for the final map.

```{r count_observations_per_neigbhorhood}

inat_neigborhoods_counts <- inat_neigborhoods %>%
  count(name, name='obs_count')  %>%
  st_drop_geometry()

head(inat_neigborhoods_counts)
```

Next use `left_join()` from **dplyr** to add `obs_count` from `inat_neigborhoods_counts` to neighborhood boundaries from `la_neighborhoods_edit`. `left_join()` will use the `name` column present in both data frames to combine the data.

```{r create_dataframe_with_neighborhood_counts_geometry}
la_counts_map <- left_join(la_neighborhoods_edit, inat_neigborhoods_counts)

head(la_counts_map)
```

`la_counts_map` has three columns: name of the neighborhood, the number of observations, and geometry.

We can now create maps showing the number of observations per neighborhood.

`aes(fill=<column_name>)` sets which column is used to determine the color of each neighborhood. `labs(fill='<title>')` sets the title show in the legend.

```{r, create_static_map_with_observations_by_neighborhood}

ggplot() +
  geom_sf(data = la_counts_map, 
          mapping=aes(fill=obs_count)) +
  labs(title = 'CNC Observations by neighborhood', 
       subtitle = '2016-2024',
       fill='Observations') +
  theme_void()



```

`zcol` sets which column to is used to determine the color of each neighborhood. `layer.name` sets the title shown in the legend. mapview does not have the ability to add a map title.

```{r create_interactive_map_with_observations_by_neighborhood}
#| eval: false
mapview(la_counts_map,  
        zcol = 'obs_count', 
        layer.name= 'Observations')
```

![](images/mapview/creating_maps/create_interactive_map_with_observations_by_neighborhood.png){fig-alt="create interactive map with observations by neighborhood"}
